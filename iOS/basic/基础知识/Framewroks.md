Advanced Mac OS X Programming



Library



来自非Unix，非C系统的常见错误程序员假设包含头文件足以使用特定库的功能。您将收到链接错误，而不是编译器错误。头文件只是告诉编译器信息，例如数据结构是什么样的，以及函数和方法的签名。一旦编译器完成生成目标文件，它就会忘记头文件。链接器从不听到标题，因此它尝试链接您的程序，但没有找到要链接的必要符号。这就是为什么即使您已在源中包含标题，也需要指定库。





Library or Frameworks

你遇到麻烦的地方是按照思路“我有一套应用程序，所以我将制作一堆共享框架，所有人都可以使用它们并将它们放在/ Library / Frameworks中。”沿着这条路走下去谎言是疯狂的。您需要管理员权限才能安装和更新框架。您将需要使用安装包或升级权限来安装框架。
一旦安装了共享框架，就需要担心版本问题。尽管框架具有一些版本控制能力，但是创建版本化框架和链接到特定版本的工具支持并不存在。因此，您将最终以锁定方式发布您的应用程序套件，可能会在完全烘焙之前发布一些应用程序，并推迟其他应用程序的发布，直到该套件的其余部分赶上。

如果您始终将框架包含在应用程序的包中，则可以避免这些问题中最严重的问题。这确实意味着公共代码和资源不会在多个应用程序之间共享，但在当今巨大磁盘和大量RAM的时代，这不是一个问题。许多商店使用静态库或只是将必要的源文件包含在他们的项目中。代码将找到相对于主bundle的资源。

Writing Plug-ins

程序开始运行后，可以按需加载共享库。它们是用于添加插件功能的机制：构建共享库并让程序加载它。通用Unix应用程序可以使用dyld函数来加载共享库并获取符号的地址（包括可执行代码的函数指针）。更高级别的应用程序可以在运行时加载包。 Cocoa可以使用NSBundle类。



Bundles in Cocoa

Bundle是包含一些可执行代码的目录，无论是共享库还是可执行程序，以及支持代码的各种资源。 Cocoa应用程序是捆绑包，框架，屏幕保护程序，iPhoto导出插件以及许多其他东西。捆绑包是Cocoa处理程序启动后加载的插件的方式。一些程序，如QuickSilver，有一个很小的主程序，所有功能都是通过插件实现的。
使应用程序接受插件有两个方面：执行加载的应用程序和插件本身。你需要让每个人都同意某种协议来相互沟通。这样做没有任何预先定义的协议，因此您可以自由使用您关心的任何机制。这是一个小命令行工具示例，它将加载返回字符串的插件，主程序将打印出来。一旦所有插件都有机会打印出他们的东西，该程序就会退出。



Shared Libraries and dlopen

如果您不想使用（或不能使用）NSBundle来加载插件，则可以加载共享库。加载共享库并不能让您随时访问NSBundle等资源。

dlopen()

dlopen()用于在给定路径下打开共享库或者包

dlopen（）打开库并解析它包含的任何符号。它返回一个模块句柄（一个不透明指针）到库中，可以在后续调用中使用，如果无法打开库，则返回NULL。函数dlerror（）返回描述错误的字符串。

路径可以是完整路径或相对路径。如果路径只是叶子名称（路径中没有斜杠，只是库名），dlopen（）使用下面的算法查找库：

1.查阅LD_LIBRARY_PATH环境变量（以冒号分隔的目录列表），并搜索目录（按顺序）以查找库。
2.如果设置了DYLD_LIBRARY_PATH环境变量，则会在叶子节点中搜索这些目录。
3.如果设置了DYLD_FALLBACK_LIBRARY_PATH环境变量，则搜索这些目录。如果
未设置此环境变量，$ HOME / lib，/ usr / local / lib，然后搜索/ usr / lib。
最后，路径被视为常规路径。

Mode参数可以采用两个控制外部函数绑定的选项之一，以及两个可选标志。这里，"外部"指的是刚刚加载的共享库中未定义的函数：

RTLD_NOW  每个外部函数都会立即绑定。您可以使用此标志来确保在加载时发现任何未定义的符号。

RTLD_LAZY  每个外部函数在第一次调用时都被绑定。您通常会使用此表单。它更有效，因为它不绑定可能永远不会被调用的函数。

RTLD_GLOBAL 这是一个可选的按位OR-in标志。除了通过调用dlsym（）可用之外，从加载的库导出的符号将可用于任何其他加载的库。这是默认行为。

RTLD_LOCAL 这也是一个可选的按位OR-in标志。从加载的库导出的符号通常是隐藏的，只有在使用此库的模块句柄时才可用于dlsym（）。



dlsym()

从dlopen（）获得模块句柄后，可以使用dlsym（）在给定符号指定的位置获取代码或数据的地址

module是dlopen（）返回的模块句柄。与dyld系列调用不同，您不会在前面添加下划线符号。如果找不到符号，则dlsym（）返回NULL，您可以查询dlerror（）以查看问题所在。

您可以为dlsym（）而不是模块句柄提供两个常量：RTLD_DEFAULT按照加载顺序搜索进程中的每个Mach-O图像。这可能是一项昂贵的操作，因为它必须涉及所有系统框架。您还可以使用RTLD_NEXT在调用dlsym（）之后加载的任何Mach-O图像中搜索符号。因此，如果您使用RTLD_NEXT在主程序中调用dlsym（），它将查看程序开始运行后加载的任何库。



BundlePrinter

那么在Mac OS X上捆绑包和共享库之间的区别是什么？实际上，不是巨大的差异。 dlopen（）可以加载它们并挖掘里面的符号。捆绑包可以卸载，而共享库则不能。使用Objective-C的Bundle必须以严格的先进先出顺序卸载，这有效地使它们无法加载。捆绑包还可以与可执行文件链接以满足缺少的符号。这允许宿主应用程序提供插件可以使用的API。