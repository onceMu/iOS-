Memory

Virtual Memory

虚拟内存是计算机伪造内存比实际内存更多的一种方式。一台机器可能有4千兆字节的RAM，但是你可以编写多次操作数据的程序。当溢出可用的实际内存量时，部分数据将保存到磁盘并在程序需要时读回。
操作系统处理脏的细节，保持当前正在物理上在内存中工作的数据，并将一段时间没有触及的数据移动到磁盘上。如果程序想要再次使用它，它还会将数据从磁盘拉回到内存中。

操作系统将内存划分为页面，操作系统寻址的4KB内存块。程序在请求内存时会给出页面。使用页面时，会保留它们在最近使用的页面列表上。当程序从系统请求越来越多的内存时，最近最少使用的页面被写入磁盘，称为“分页”或“交换”，并重新使用物理内存块。 iOS没有这种基于磁盘的交换文件，因此您将在该平台上比桌面Mac OS X更快地达到内存不足的状态。

程序在特定时间分配给它的内存总量称为虚拟集。实际位于RAM中的内存量称为驻留集。虚拟集和驻留集之间的差异存储在交换文件中的磁盘上，或者存储在只读代码段（如系统框架）的文件中。 “交换”从发生分页时彼此交换的页面中获取其名称。您还可以锁定或连接内存，以便不会被换出。您绝对不希望换出的某些页面，例如包含解密密码的页面。在解密密码之前，应使用mlock（）函数连接这些页面。

页面可以具有权限，如只读，读/写和执行。这有助于防止您对自己的代码进行涂鸦，并有助于防止尝试从未标记为可执行文件的页面执行代码的安全漏洞。



Program Memory Model

Mac OS X进程有一个概念性内存模型，内存分位可执行代码空间，堆栈，堆和其它.

Text Segment   Text段

​	可执行代码位于此处。在程序启动的时候，代码从磁盘上的可执行文件映射到内存中作为只读页面，由于页面是只读，所有可以在多个进程之间共享，因此页面只需要在物理内存中出现一次，就可以在多个用户之间共享。当然，他们也可以在其他进程的虚拟内存中出现多次。这尤其适用于加载到每个程序中的共享库，数据是只读的，所以内核可以回收这些页面而无需将她们写入交换文件。

Initialized Data Segment  已初始化数据段

​	初始化的全局变量和静态变量都存储在此处。初始化数据是存储在数据段本身中，数据段本身只是复制到内存中，然后程序可以修改读/写页面。因为内核只是从磁盘读取数据块，所以加载和初始化所有全局变量非常快。没有真正的显式初始化，只是批量数据加载。

Uninitialized Data Segment 未初始化数据段

​	这是所有存在于在全局空间单没有给出明确初始化器的字段，例如函数内部的int bork 或者函数内部的静态char buffer[5000]，在程序启动的时候未初始化数据段会被清零。这些段不会被认为是已初始化数据段，这就意味着可执行文件中有许多零散的区域。仅存储此数据段的大小。在程序加载时，操作系统会分配该空间量并且填充为零。

​	这也通常被称为BBS，BBS来自于汇编指令，意思着 由符号启动的块。

Heap   堆

​	堆是动态（运行时）分配的区域，如果你调用malloc（）40k 内存大小，这40k来自于堆。

Program Stack   程序堆栈

​	主线程调用堆栈。存储了本地（自动）变量以及每个变量的堆栈帧。当函数调用另外一个函数时，需要在调用新函数之前存储处理器的寄存器和其余各种相关的内容。这些数据在新函数退出时，还需要进行恢复。

​	使用程序堆栈的内存分配非常快，处理器寄存器用于指示堆栈末尾的位置。在堆栈上保留空间只需要添加一个值到这个地址，无论是4个字节还是4000个字节。您不希望在堆栈上存储太多内容，例如大缓冲区，因为堆栈的大小有限制。另外，线程具有有限的堆栈空间，因为每个线程都有自己的内存块用于堆栈。



Memory Lifetime

​	初始化的数据段和未初始化的数据段存在于程序整个运行期间。它们在程序运行期间不会消失。堆上的内存都是显式的初始化然后明确释放的。堆上的内存可以在程序控制下释放。堆上的内存消失，意味着它一旦超出范围，就可以被其它地方重用。即使是在函数退出之前，就像在函数内的大括号分隔的块中一样。如果您假设内存的有效时间比实际长，则堆栈内存的操作可能会出现问题。经典的错误是返回堆栈上的地址。

​	缓冲区在堆栈上分配。堆栈上有五千个字节，缓冲区包含第一个字节的地址。一旦缓冲区超出返回，该内存将可让其它功能使用。任何使用borkulize（）的返回结果的人都有可能会有人破坏其内容。可能在此功能退出后很久，导致很难找到的错误。



Dynamic Memory Allocation  动态内存分配

​	动态内存是来自于堆的内存。程序堆开始于OS定义的可用于程序消耗的默认空间量。当您从堆中分配内存时，它会填满，然后你的程序会从操作系统申请更多内存。程序释放的内存可以被程序再次重用。内存的分配和随后释放的内存任然由操作系统记录在你的程序中。如果为临时工作区分配50M字节的内存然后全部释放，程序仍将分配50M字节。当你没有使用这个内存的时候，在桌面系统上可能会被置换到磁盘。内存的总量将会被标记为一个很高的使用量。

​	malloc()

​	free()

​	realloc()

​	calloc()





Memory Ownership Issues

​	使用动态内存时遇到的一个困难是对于一块已经分配的内存，当没有任何人使用的时候由谁来负责释放它。这被称为内存所有权。这个问题有很多不同到的解决方案，每个方案都有自己的权衡和好处。如Java 和 Cocoa的垃圾回收，Cocoa的引用计数。

​	对于Unix和C语言的库调用，没有统一的内存所有权规则。例如：

​	getenv（） 返回一个 char *类型，但是你不需要释放它，因为环境变量都存储在全局数组中，而getenv（）只返回该数组中包含的字符串。



Debugging Memory Problems

MallocStackLogging

MallocStackLoggingNoCompact



Guard Malloc

​	Xcode附带了libgmalloc(Guard Malloc)，这是一个很有用的调试malloc库，用于捕获内存溢出错误。

​	当弃用libgmalloc的时候，每个内存分配都放在它自己的虚拟内存页面上，缓冲区的末尾放在页面内存的末尾。下一页保持未分配状态。如果尝试访问超出缓冲区末尾的位置，则会生成信号。浙江立即捕获端到端的错误。

​	释放内存时，libgmalloc会释放其虚拟内存，导致后续读取或写入导致总线错误。由于虚拟内存系统承受的额外压力，您的应用程序可能会慢十到一百倍，因此您可能不希望一直运行这个。但是当你需要帮助追踪令人讨厌的内存损坏问题时，这可以节省生命。



Memory Leaks  内存泄漏





Objective-C Garbage Collection

​	Objective-C 2.0将垃圾收集添加到语言中，以替代传统的保留/释放引用计数方案。垃圾收集是自动对象内存管理。垃圾收集器计算出其他对象引用的对象，如果没有人对它感兴趣，收集器将销毁该对象。对于使用Java或Python等语言的程序员来说，这是一种熟悉的行为，其中内存管理“恰好发生”。
​	Objective-C垃圾收集是选择加入的。您可以选择使用GC或继续使用引用计数。 iOS目前不支持GC，因此您必须在那里使用引用计数。 Apple建议将GC用于新应用程序，但您可以改进旧应用程序以使用它。 Xcode是一个大型应用程序的示例，已经过改进以使用GC。自从最初在Leopard中引入以来，采用GC将您限制在OS X 10.5或更高版本中。如果您的现有应用程序使用大量非Cocoa代码（例如Carbon或C ++库），也可能很难采用。
​	Objective-C GC是为Objective-C代码和Objective-C对象设计的，因为这是编写和优化平台的大部分代码的地方。因为Objective-C是C的超集，所以我们仍然有指针，这些可能会使一些内存管理方案复杂化。
​	Apple的GC是一个保守的，分代的和并发的垃圾收集器。保守的垃圾收集器永远不会复制或移动指针。一旦你分配了内存，它就会粘到它首先登陆的地址。这意味着您可以分配缓冲区然后将其传递给C函数，而不用担心内存意外浮动。
分代垃圾收集器假定新对象快速转向垃圾。随着年龄的增长，物体往往会粘在一起。世代收集器在查找垃圾时专注于新对象，并且只在一小部分时间内查看旧对象，而不是在每个垃圾收集周期中扫描每个对象。 Apple声称，当使用世代模型时，90％的对象可以通过10％的努力得到恢复。
​	并发垃圾收集器在其自己的线程上运行。它还可以在分配其他对象时收集对象。 Apple的收集器在收集时不会立即停止所有线程，并且它试图不会中断任何线程很长时间。不使用任何Objective-C代码的线程将不会被收集器停止。每个线程都有一个线程本地收集器，它还可以提高GC并发性。

How it works

​	GC memory 被分成4种类型

​	1.静态数据段中的全局变量

​	2.线程堆栈上的局部变量

​	3.GC 堆，所有可收集的内存都存在

​	4.themalloc（）区域

​	前三个在GC中起到了很大的作用。

​	收集器扫描内存来找出还被引用的内存。扫描器从众所周知的根位置开始，特别是全局变量和局部变量，然后通过内存扫描查找内容。主要检测下面内容：

​	1.OC 对象的实例变量和全局变量

​	2.实例变量和全局变量被标记为(__strong)

​	3.线程堆栈，具有关联的NSThread堆栈

​	4.一些已明确分配为可收集且应扫描的堆快

​	收集器扫描所有这些区域，寻找看起来像指针的内容。然后构建连接和未连接对象的数据结构。具有连接到根的对象是good的。没有这种连接的对象被视为垃圾并放在列表中。收集器扫描完成后，会遍历垃圾清单，将对垃圾的弱引用清零，会给垃圾列表中的每个对象发送 -finalize 消息，并回收内存。

​	收集器不查看C指针类型的实例变量和全局变量，也不查看malloc（）或vm_malloc（）的堆快，如果将可收集对象的地址放入到malloc'd 块中，可能会导致问题。收集器不会看到这些引用，因此它可能会在实际垃圾之前收集它。





Strong and weak references

​	指向可收集内存块的指针可以是强引用或弱引用。强引用告诉收集器不要收集对象，因为对象正在被使用。收集器通过遵循强引用来查找对象，一旦指向对象的所有强引用都被删除了，收集器就会收集该对象。

​	弱引用告诉收集器对所指向的对象感兴趣，但是一旦所有强引用都消失，强迫对象保持不变就没有足够的兴趣。当弱引用对象被收集的时候，指向该对象的指针会被设置为nil。

​	默认情况下，对象指针都是__strong。

​	被分配给footCountRef的可收集内存，collector将确保不收集该对象。如果声明中缺少__strong标识符，收集器不会将此视为对内存的引用，除非是被认为是强引用的局部变量。

​	编译器生成写入障碍来捕获具有强引用的变量的赋值。写屏蔽只是一个函数调用，如objc-auto.h文件中的objc_assign_ivar()或objc_assign_gloal()函数。基于堆栈的变量不会为了提高效率而生成写入障碍。相反，collectors是扫描整个的堆栈来查找指针而不是使用写入障碍。

​	当弱引用指向的对象被删除时，弱引用会自动归零。访问弱引用的时候，你要么得到该对象，要么得到nil。这意味着不会获得悬空指针。

​	当弱引用对象发生变化的时候，编译器除了生成写入障碍之外，还会生成一个读障碍。读取屏蔽捕获了收集指向对象时的情况，然后当收集器尚未到达时将对象归零，然后在访问时将其归零。

​	弱引用仅限于实例变量和全局变量。你不能生成一个弱的局部变量。当扫描器扫描调用堆栈时发现局部变量是弱引用，编译器不能告诉收集器任何信息。因为读取屏障，弱引用开销比强引用要大很多。强引用是正常的内存读取，但弱引用通过读取屏障功能读取。同时，线程可以阻塞读屏障，同时清除弱引用。



Finalize methods

​	使用GC时从不调用-dealloc方法。相反，当一个对象遇到它的最终消亡时，收集器调用对象的-finalize方法让对象进行任何最终的清理。Finalize method并不想它听起来那么方便，如果可能的话应该避免调用。

​	在收集器通过对象查看什么是垃圾对象之后，收集器就会清除对象的弱引用。然后以任意顺序调用finalize方法。终结器中的消息传递对象可能会发现您已将消息发送到已完成的对象。终结器也必须是线程安全的。它们可以在收集器线程或其它线程调用。此外，由于以任意顺序调用finalize方法，因此可能在对象完成后对其进行消息传递，您也不能依赖于何时调用finalize（）方法。

​	这些限制使得使用终结器不便于进行与内存无关的清理，例如关闭文件或终止网络链接。Apple不建议将资源管理和内存管理结合在一起，而是建议对API进行特定的调用，例如-closeFile or -terminateNetworkConnection。通过这种方法，你可以完全没有任何终结方法。如果您有需要收集的内存缓冲区，请考虑使用NSMutableData或NSAllocateCollectable()方法，他们将自动清理内存。

​	

Non Objective-C objects

​	除了OC对象外，收集器还可以出路Core Foundation对象以及可收集内存的任意block。CF*Ref 对象是收集器禁用到的GC对象，不被视为GC类型，因此Core Foundation指针不被视为__strong 指针。如果你想CF对象可以收集，你应该调用CFRelease()或者CFMakeCollectable()方法。

​	当GC可用的时候，-retain、-release和-autorelease方法变味no-ops，这些方法在方法调度中被拦截。因此，自动释放CF对象将不会执行任何操作，并且对象将会泄漏。

​	如前所属，指向可收集内存的指针不应存储在从malloc（）接收的内存块中，因为收集器不会扫描这些块已查看内存引用是否仍然存在。但是可以通过NSAllocateCollectable（）来获取可收集内存块。

​	

External reference counts

​	即使GC对象看起来没有引用计数，实际上也是如此，但它被默认是0.当此引用计数为0的时候，收集器假定它处于控制中，并且在认为没有更多的强引用时清理它。档次引用计数不为零时，收集器将其单独保留。如果将对象存储在收集器看不到的位置，则可以使用此对象保持对象的活动状态。

​	你通过调用CFRetain()或者使用NSGarbageCollector’s -disableCollectorForPointer方法来增加引用计数。同时，通过CFRelease（）方法或者-enableCollectorForPointer方法来减少引用。



The New collection classes

​	在缓存数据时，弱引用很有用。当缓存对象因为任何原因被移除的时候，弱引用将会被清零。如果Cocoa集合类(NSArray、NSSet等)支持通过弱引用自动删除，那将是很好。不幸的是，这些集合不能包含nil值。

​	幸运的是，自NextStep早期开始，有一些基于函数指针的准对象已经存在于Cocoa中，如NSMapTable和NSHashTable。与Cocoa的其余部分相比，相关的API具有强烈的C语言风格，而且根本不是面向对象的。Apple已经采用了这些类，将它们客观化，并使它们在GC的直接中变得可用。

​	NSMapTable 像一个包含键和值的字典，但是你可以拥有弱键保持的key或者value。当其中一个相关的对象被收集，将删除对应的条目。NSHashTable就像一个集合，在收集对象时可以删除条目。一个全新的class，NSPointerArray已经被引入，其行为类似于NSArray，但是可以保存nil值。



GC and threads

​	通过NSThread创建的线程将由收集器抓取其堆栈以查明活跃引用。由pthread api创建的threads将不会被收集，除非你在该线程中进行NSTread调用或者创建自动释放池。这样就会在收集器中注册该线程。性能关键的线程（如音频或视频）不能被收集。收集器可以暂时中断线程以完成其工作。

​	如果将GC内存从一个线程传递到另一个线程，要注意竞争条件。在线程启动之前可能会收集内存并可以添加自己的引用。这就是使用外部引用计数的好地方，在启动线程之前增加外部引用函数，然后在新线程内减少它。



