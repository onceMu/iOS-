Memory

Virtual Memory

虚拟内存是计算机伪造内存比实际内存更多的一种方式。一台机器可能有4千兆字节的RAM，但是你可以编写多次操作数据的程序。当溢出可用的实际内存量时，部分数据将保存到磁盘并在程序需要时读回。
操作系统处理脏的细节，保持当前正在物理上在内存中工作的数据，并将一段时间没有触及的数据移动到磁盘上。如果程序想要再次使用它，它还会将数据从磁盘拉回到内存中。

操作系统将内存划分为页面，操作系统寻址的4KB内存块。程序在请求内存时会给出页面。使用页面时，会保留它们在最近使用的页面列表上。当程序从系统请求越来越多的内存时，最近最少使用的页面被写入磁盘，称为“分页”或“交换”，并重新使用物理内存块。 iOS没有这种基于磁盘的交换文件，因此您将在该平台上比桌面Mac OS X更快地达到内存不足的状态。

程序在特定时间分配给它的内存总量称为虚拟集。实际位于RAM中的内存量称为驻留集。虚拟集和驻留集之间的差异存储在交换文件中的磁盘上，或者存储在只读代码段（如系统框架）的文件中。 “交换”从发生分页时彼此交换的页面中获取其名称。您还可以锁定或连接内存，以便不会被换出。您绝对不希望换出的某些页面，例如包含解密密码的页面。在解密密码之前，应使用mlock（）函数连接这些页面。

页面可以具有权限，如只读，读/写和执行。这有助于防止您对自己的代码进行涂鸦，并有助于防止尝试从未标记为可执行文件的页面执行代码的安全漏洞。



Program Memory Model

Mac OS X进程有一个概念性内存模型，内存分位可执行代码空间，堆栈，堆和其它.

Text Segment   Text段

​	可执行代码位于此处。在程序启动的时候，代码从磁盘上的可执行文件映射到内存中作为只读页面，由于页面是只读，所有可以在多个进程之间共享，因此页面只需要在物理内存中出现一次，就可以在多个用户之间共享。当然，他们也可以在其他进程的虚拟内存中出现多次。这尤其适用于加载到每个程序中的共享库，数据是只读的，所以内核可以回收这些页面而无需将她们写入交换文件。

Initialized Data Segment  已初始化数据段

​	初始化的全局变量和静态变量都存储在此处。初始化数据是存储在数据段本身中，数据段本身只是复制到内存中，然后程序可以修改读/写页面。因为内核只是从磁盘读取数据块，所以加载和初始化所有全局变量非常快。没有真正的显式初始化，只是批量数据加载。

Uninitialized Data Segment 未初始化数据段

​	这是所有存在于在全局空间单没有给出明确初始化器的字段，例如函数内部的int bork 或者函数内部的静态char buffer[5000]，在程序启动的时候未初始化数据段会被清零。这些段不会被认为是已初始化数据段，这就意味着可执行文件中有许多零散的区域。仅存储此数据段的大小。在程序加载时，操作系统会分配该空间量并且填充为零。

​	这也通常被称为BBS，BBS来自于汇编指令，意思着 由符号启动的块。

Heap   堆

​	堆是动态（运行时）分配的区域，如果你调用malloc（）40k 内存大小，这40k来自于堆。

Program Stack   程序堆栈

​	主线程调用堆栈。存储了本地（自动）变量以及每个变量的堆栈帧。当函数调用另外一个函数时，需要在调用新函数之前存储处理器的寄存器和其余各种相关的内容。这些数据在新函数退出时，还需要进行恢复。

​	使用程序堆栈的内存分配非常快，处理器寄存器用于指示堆栈末尾的位置。在堆栈上保留空间只需要添加一个值到这个地址，无论是4个字节还是4000个字节。您不希望在堆栈上存储太多内容，例如大缓冲区，因为堆栈的大小有限制。另外，线程具有有限的堆栈空间，因为每个线程都有自己的内存块用于堆栈。



Memory Lifetime

​	初始化的数据段和未初始化的数据段存在于程序整个运行期间。它们在程序运行期间不会消失。堆上的内存都是显式的初始化然后明确释放的。堆上的内存可以在程序控制下释放。堆上的内存消失，意味着它一旦超出范围，就可以被其它地方重用。即使是在函数退出之前，就像在函数内的大括号分隔的块中一样。如果您假设内存的有效时间比实际长，则堆栈内存的操作可能会出现问题。经典的错误是返回堆栈上的地址。

​	缓冲区在堆栈上分配。堆栈上有五千个字节，缓冲区包含第一个字节的地址。一旦缓冲区超出返回，该内存将可让其它功能使用。任何使用borkulize（）的返回结果的人都有可能会有人破坏其内容。可能在此功能退出后很久，导致很难找到的错误。



Dynamic Memory Allocation  动态内存分配

​	动态内存是来自于堆的内存。程序堆开始于OS定义的可用于程序消耗的默认空间量。当您从堆中分配内存时，它会填满，然后你的程序会从操作系统申请更多内存。程序释放的内存可以被程序再次重用。内存的分配和随后释放的内存任然由操作系统记录在你的程序中。如果为临时工作区分配50M字节的内存然后全部释放，程序仍将分配50M字节。当你没有使用这个内存的时候，在桌面系统上可能会被置换到磁盘。内存的总量将会被标记为一个很高的使用量。

​	malloc()

​	free()

​	realloc()

​	calloc()





Memory Ownership Issues

​	使用动态内存时遇到的一个困难是对于一块已经分配的内存，当没有任何人使用的时候由谁来负责释放它。这被称为内存所有权。这个问题有很多不同到的解决方案，每个方案都有自己的权衡和好处。如Java 和 Cocoa的垃圾回收，Cocoa的引用计数。

​	对于Unix和C语言的库调用，没有统一的内存所有权规则。例如：

​	getenv（） 返回一个 char *类型，但是你不需要释放它，因为环境变量都存储在全局数组中，而getenv（）只返回该数组中包含的字符串。



Debugging Memory Problems

MallocStackLogging

MallocStackLoggingNoCompact



Guard Malloc

​	Xcode附带了libgmalloc(Guard Malloc)，这是一个很有用的调试malloc库，用于捕获内存溢出错误。

​	当弃用libgmalloc的时候，每个内存分配都放在它自己的虚拟内存页面上，缓冲区的末尾放在页面内存的末尾。下一页保持未分配状态。如果尝试访问超出缓冲区末尾的位置，则会生成信号。浙江立即捕获端到端的错误。

​	释放内存时，libgmalloc会释放其虚拟内存，导致后续读取或写入导致总线错误。由于虚拟内存系统承受的额外压力，您的应用程序可能会慢十到一百倍，因此您可能不希望一直运行这个。但是当你需要帮助追踪令人讨厌的内存损坏问题时，这可以节省生命。



Memory Leaks  内存泄漏





Objective-C Garbage Collection

​	Objective-C 2.0将垃圾收集添加到语言中，以替代传统的保留/释放引用计数方案。垃圾收集是自动对象内存管理。垃圾收集器计算出其他对象引用的对象，如果没有人对它感兴趣，收集器将销毁该对象。对于使用Java或Python等语言的程序员来说，这是一种熟悉的行为，其中内存管理“恰好发生”。
​	Objective-C垃圾收集是选择加入的。您可以选择使用GC或继续使用引用计数。 iOS目前不支持GC，因此您必须在那里使用引用计数。 Apple建议将GC用于新应用程序，但您可以改进旧应用程序以使用它。 Xcode是一个大型应用程序的示例，已经过改进以使用GC。自从最初在Leopard中引入以来，采用GC将您限制在OS X 10.5或更高版本中。如果您的现有应用程序使用大量非Cocoa代码（例如Carbon或C ++库），也可能很难采用。
​	Objective-C GC是为Objective-C代码和Objective-C对象设计的，因为这是编写和优化平台的大部分代码的地方。因为Objective-C是C的超集，所以我们仍然有指针，这些可能会使一些内存管理方案复杂化。
​	Apple的GC是一个保守的，分代的和并发的垃圾收集器。保守的垃圾收集器永远不会复制或移动指针。一旦你分配了内存，它就会粘到它首先登陆的地址。这意味着您可以分配缓冲区然后将其传递给C函数，而不用担心内存意外浮动。
分代垃圾收集器假定新对象快速转向垃圾。随着年龄的增长，物体往往会粘在一起。世代收集器在查找垃圾时专注于新对象，并且只在一小部分时间内查看旧对象，而不是在每个垃圾收集周期中扫描每个对象。 Apple声称，当使用世代模型时，90％的对象可以通过10％的努力得到恢复。
​	并发垃圾收集器在其自己的线程上运行。它还可以在分配其他对象时收集对象。 Apple的收集器在收集时不会立即停止所有线程，并且它试图不会中断任何线程很长时间。不使用任何Objective-C代码的线程将不会被收集器停止。每个线程都有一个线程本地收集器，它还可以提高GC并发性。

How it works

​	GC memory 被分成4种类型

​	1.静态数据段中的全局变量

​	2.线程堆栈上的局部变量

​	3.GC 堆，所有可收集的内存都存在

​	4.themalloc（）区域

​	前三个在GC中起到了很大的作用。

​	收集器扫描内存来找出还被引用的内存。扫描器从众所周知的根位置开始，特别是全局变量和局部变量，然后通过内存扫描查找内容。主要检测下面内容：

​	1.OC 对象的实例变量和全局变量

​	2.实例变量和全局变量被标记为(__strong)

​	3.线程堆栈，具有关联的NSThread堆栈

​	4.一些已明确分配为可收集且应扫描的堆快

​	收集器扫描所有这些区域，寻找看起来像指针的内容。然后构建连接和未连接对象的数据结构。具有连接到根的对象是good的。没有这种连接的对象被视为垃圾并放在列表中。收集器扫描完成后，会遍历垃圾清单，将对垃圾的弱引用清零，会给垃圾列表中的每个对象发送 -finalize 消息，并回收内存。

​	收集器不查看C指针类型的实例变量和全局变量，也不查看malloc（）或vm_malloc（）的堆快，如果将可收集对象的地址放入到malloc'd 块中，可能会导致问题。收集器不会看到这些引用，因此它可能会在实际垃圾之前收集它。





Strong and weak references