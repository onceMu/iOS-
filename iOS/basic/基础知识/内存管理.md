内存管理

MRC

ARC

strong、weak、autorelease、copy、mutablecopy、assign内部实现原理





Runtime

Instance 变量、class、metaClass、isa

类对象存储

类方法、实例方法存储

关联对象

runtime使用等



Runloop



GCD



KVC && KVO

常用设计模式

第三方库源码

MVVM与MVP

响应式编程

ReactNative

Git







内存管理

MRC

1.自己生成，自己持有。alloc、new、copy、mutableCopy

2.非自己生成的，自己也能持有。retain、copy、mutableCopy等方法

3.不再需要自己持有的对象时释放。release、autorelease、

4.非自己持有的对象无法释放。



ARC是在编译期进行的优化



ARC

Super 关键字 的意思是说查找算法从当前类的superclass中查找。

所有权修饰符

  __strong

​	id 类型和对象默认的所有权修饰符。id和对象在没有明确指定修饰符的时候，默认都是__strong 修饰符。附有 _strong 标识符的变量obj在超出其作用域是后，变量被废弃掉。

  __weak

​	__weak 修饰符的变量（弱引用）不持有对象，所以在超出其变量作用域时，对象即被释放。在持有某对象的弱引用时，如果该对象被废弃掉，则弱引用将自动失效且处于nil被赋值的状态。

  __unsafe_unretained

​	与__weak 类似，但是不会将对象置为nil

__autoreleasing 

​	ARC有效的时候，需要将对象赋值给附加了__autoreleasing 修饰符的变量来替代调用autorelease方法。

​	一般不显示地加__autoreleasing 修饰符。

​	访问__weak 修饰符的变量时，实际上必定要访问注册到autoreleasepool的对象。



属性

ARC情况下，属性对应的修饰符也发生了变化

|       属性        |          所有权修饰符          |
| :---------------: | :----------------------------: |
|      assign       |      __unsafe_unretained       |
|       copy        | __strong(赋值的是被复制的对象) |
|      retain       |            __strong            |
|      strong       |            __strong            |
| unsafe_unretained |      __unsafe_unretained       |
|       weak        |             __weak             |

__strong、__weak、autoreleasing 修饰符保证其指定的变量初始化为nil



weak 需要运行时支持

clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mmacosx-version-min=10.7 -fobjc-runtime=macosx-10.7 -Wno-deprecated-declarations main.m



桥接技术

CoreFoundation 框架的类型对象和OC类型的对象内存管理方式不一致。

CF中还是使用MRC来管理，OC使用ARC或者MRC来管理。

桥接可以转换OC和CF对象之间的管理方式

 __bridge 修饰符，只是声明类型转变，不做内存管理规则的转变

 __bridge_retained 修饰符或者 CFBridgingRetain函数，转换指针类型的同时，也将内存管理的责任由OC转换到了 CF 来处理

__bridge_transfer修饰符 或者 CFBridgingRelease函数，转换指针类型的同时，也将内存管理有CF转成了OC





消息机制在类中动态找到的实际方法不是在类中声明的方法，也就是说不是@interface声明的方法，而是在@implementation 中定义的方法。但是在编译期间，类型检查是根据@interface 中声明的方法完成的。



Class extension(类扩展)是ivars和方法的集合，可以允许将类@interface中的方法拆分成多个文件，但是任然有一个主要文件能看到@interface中的所有方法。

Category 中的@implementation 的实现方法可以动态的加载到类的方法表中，这些操作是在运行时进行的，如果有方法冲突就会替换掉相应的方法。



Autorelease pool ，对象的局部线程列表在稍后的时间会调用release方法。对象调用autorelease方法可以将对象加入当前的pool中。



Runloop

1.Autorelease Pools

​	runloop 的一个主要作用是管理autorelease pool。所有的autorelease pool都是由runloop管理的。

