Block 带有自动变量（局部变量）的匿名函数

自动变量

函数的参数

静态变量（静态局部变量）

静态全局变量

全局变量



静态存储区：存放全局变量和静态变量，在程序执行前分配存储空间，占据固定的存储单元。

动态存储区：存放函数的局部变量、函数的返回值、行参等。



static变量

静态局部变量

​	1.在函数内部定义，生命周期是整个源程序，作用域与自动变量相同，只能在定义该变量的函数内使用。退出函数后，变量继续存在，但不能使用。

​	2.允许对构造类静态局部变量赋初值。

​	3.对基本类型的静态局部变量若没有赋初值，系统默认赋值0，自动变量不赋初值，自动变量值不定。虽然离开定义的函数之后不能使用，但是再次调用定义其函数的时候，又可以继续调用，并且保存了上次的值。

​	比如:在函数中定义一个static int a，然后打印a，这时候a 是0，赋值 a 为100，下次进这个函数a 就是100。



静态全局变量

​	全局变量之前加上static 就是静态全局变量。全局变量本身是静态方式存储。静态全局变量与全局变量的区别是 全局变量的作用域是整个源程序，而静态全局变量的作用域是定义该变量的源文件有效。

把局部变量改成静态局部变量之后，改变了其存储方式，即生命周期。把全局变量改成静态全局变量后，改变了其作用域，限制了使用范围。



自动变量

​	auto，非静态变量的局部变量即为自动变量。

寄存器

​	register，使用寄存器可以提高执行效率，只有局部变量才可以定义为寄存器变量，但不能大量使用寄存器，寄存器数目有限。





 block 函数会自动截取block之前的自动变量，在block 声明之后自动变量值发生改变，block内部捕获的值也不会改变。自动变量值截获只能保存执行block语法瞬间的值。如果尝试在block内部修改捕获的自动变量，编译器会报错。

如果要将Block中的值赋值给Block语法外声明的自动变量，需要在该自动变量上附加__block 修饰符。

如果自动捕获的是OC对象，比如NSMutableArray，在block内部调用对象方法，是可以运行的，但是如果给OC对象赋值，就会编译错误。

void (^blk)(void) = ^{

​            printf("Block\n");

​        };

​        blk();

将OC文件改成成C++之后，可以查看Block的本质



__main_block_impl_o *结构体指针

static void __main_block_func_0(struct _ _main_block_impl_0 *__cself) {

​            printf("Block\n");

}

_ _main_block_impl_0 结构体指针

_ _block_impl 结构体

Block 中使用的变量都会被定义到 _ _main_blcok_impl_0 结构体中，变量类型与捕获之前的变量类型一致。



Block只捕获自动变量。

静态全局变量、全局变量 不捕获

静态变量会捕获，捕获的静态变量使用静态变量的指针进行访问。



静态局部变量在block内部使用指针进行访问。

静态变量的方式貌似也可以用于存超过其作用域的被截取对象的自动变量。但是当超过作用域之后，仍然不能通过指针访问。



__block 标识符，用于指定将变量值设置到哪个存储域中。

__block 标识符的对象会被转换成 __Block_byref_val_0 结构体指针

__Block_byref_val_0 结构体



Block是OC对象，

_NSConcreteStackBlock

_NSConcreteGlobalBlock

_NSConcreteMallockBlock



_NSConcreteGlobalBlock

不需要对自动变量进行截获，