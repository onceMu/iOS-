逻辑与 &

逻辑或 |

逻辑异或 ^

逻辑非 ~

位级运算常用方法是实现掩码运算。



.text   已编译程序的机器代码

.rodata  只读数据，如printf语句中的格式串和开关语句的跳转表

.data   已初始化的全局和静态C 变量，以及所有被初始化为0 的全局或静态变量，在目标文件中这个节不占据实际的空间，仅仅是一个占位符。

.symtab   符号表，存放在程序中定义和引用的函数和全局变量的信息

.rel.text.  

.rel.data 

.debug 调试符号表

.line

.strtab



定义为带有C static 属性的本地过程变量是不在栈中管理的。编译器在.data  和 .bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。



COMMON 未初始化的全局变量

.bss   未初始化的静态变量，以及初始化为0的全局或静态变量



连接器如何解析多重定义的全局符号

1.不允许有多个同名的强符号

2.如果有一个强符号和多个弱符号同名，选择强符号

3.如果有多个弱符号，从弱符号中任意选择一个。







共享库的一个主要目的是允许多个正在运行的进程共享内存中相同的库代码。

多个进程是如何共享程序的一个副本呢？

1.给每个共享库事先预备的专用地址空间片，然后要求加载器总是在这个地址加载共享库。 方法简单，但是问题比较严重。1.对地址空间使用效率不高，进程不使用这个库，空间还是会被分配出来，难以管理，必须保证没有片重叠，如果库修改之后，必须确认已经分配的片大小是否合适，如果不合适还需要更新换的片。如果创建一个新的库，还需要寻找新的空间。



2.现代系统 编译共享模块的代码段，使得可以把他们加载到内存的任何位置而无需链接器修改，这样无限多个进程可以共享一个共享模块的代码段的单一副本。（称为PIC，position-independent code 位置无关代码）



PIC数据引用

无论在内存中的何处加载一个目标模块（包含共享目标模块），数据段与代码段的距离总是保持不变。代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量。与代码段和数据段的绝对内存位置是无关的。

在数据段开始的地方创建了一个全局便宜量表（Global Offset Table,GOT）。



PIC函数调用

程序在调用一个由共享库定义的函数的时候，编译器是没有办法预测函数的运行时地址。因为定义它的共享模块在运行时可以加载到任意位置。GNU 通过延迟绑定（lazy binding）来解决这个问题。将过程地址的绑定推迟到第一次调用该过程时。这样可以避免动态链接器在加载时进行成百上千并不需要的重定位。

延迟绑定通过两个数据结构来实现，GOT(Global Offset Table) PLT(Procedure Linkage Table过程链接表)

PLT 是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，跳转到动态链接器中。







库打桩机制

编译时打桩   需要访问源代码

运行时打桩   需要能访问程序的可重定位对象文件  动态链接器的LD_PRELOAD 环境变量能只需要访问可执行目标文件





GNU binutils常用命令

1.AR  创建静态库，插入、删除、列出和提取成员

2.STRINGS 列出一个目标文件中所有可打印的字符串

3.STRIP  从目标文件中删除符号表信息

4.NM  列表目标文件的符号表中定义的符号

5.SIZE  列表目标文件中节的名字和大小

6.READELT 显示目标文件的完整结构，包括SIZE和NM

7.OBJDUMP  能显示一个目标文件中所有的信息， 主要是用来反汇编.text节中的二进制指令

8.LDD 列出可执行文件在运行时需要的共享库



链接可以在编译时由静态编译器完成，也可以在加载时和运行时由动态链接器来完成。链接器处理的是 目标文件的二进制文件，包含可重定位的、可执行和共享的三种形式。

可重定位的是由静态链接器链接和加载的，





进程

一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。





