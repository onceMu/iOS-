十大经典排序算法

1.非线性时间比较类排序

	通过比较来决定元素的相对次序，时间复杂度不突破O(nlogn)

2.线性时间比较类排序

​	不通过比较来决定元素间的相对次序，可以突破基于比较排序的时间下限，以线性时间运行。	

​				             非线性时间比较类排序

| 交换排序 |   插入排序   |   选择排序   |   归并排序   |
| :------: | :----------: | :----------: | :----------: |
|   冒泡   | 简单插入排序 | 简单选择排序 | 二路归并排序 |
| 快速排序 |   希尔排序   |    堆排序    | 多路归并排序 |

​                                                     线性时间非比较类排序

| 基数排序 | 桶排序 | 基数排序 |
| :------: | :----: | :------: |
|          |        |          |

算法时间复杂度

| 排序方法 | 平均时间复杂度 |   最坏   |   最好   | 空间复杂度 | 稳定性 |
| :------: | :------------: | :------: | :------: | :--------: | :----: |
| 插入排序 |     O(n²)      |  O(n²)   |   O(n)   |    O(1)    |  稳定  |
| 希尔排序 |    O(n1.3)     |  O(n²)   |   O(n)   |    O(1)    | 不稳定 |
| 选择排序 |     O(n²)      |  O(n²)   |  O(n²)   |    O(1)    | 不稳定 |
|  堆排序  |    O(n㏒2n)    | O(n㏒2n) | O(n㏒2n) |    O(1)    | 不稳定 |
| 冒泡排序 |     O(n²)      |  O(n²)   |   O(n)   |    O(1)    |  稳定  |
| 快速排序 |    O(n㏒2n)    |  O(n²)   | O(n㏒2n) |  O(n㏒2n)  | 不稳定 |
| 归并排序 |    O(n㏒2n)    | O(n㏒2n) | O(n㏒2n) |    O(n)    |  稳定  |
|          |                |          |          |            |        |
| 计数排序 |     O(n+k)     |  O(n+k)  |  O(n+k)  |   O(n+k)   |  稳定  |
|  桶排序  |     O(n+k)     |  O(n²)   |   O(n)   |   O(n+k)   |  稳定  |
| 基数排序 |     O(n*k)     |  O(n*k)  |  O(n*k)  |   O(n+k)   |  稳定  |



稳定：如果a原本在b前面，而a=b，排序之后a任然在b的前面

不稳定：如果a原本在b前面，而a=b，排序之后a可能会出现在b后面

时间复杂度：对排序数据的总的操作次数，反应当n变化时，操作次数呈现什么规律

空间复杂度：指算法在计算机内执行时所需存储空间的度量，数据规模n的函数。



冒泡排序 Bubble Sort

重复地走访要排序的数列，一次比较两个元素，如果顺序错误就交换，重复到最后一个就完成。

描述：

​	1.比较相邻的元素，如果第一个比第二个大，交换两个；

​	2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，在最后的元素应该是最大的数；

​	3.针对所有的元素重复以上的步骤，除了最后一个

​	4.重复步骤1~3，直到排序完成。



选择排序

首先在未排序数列中找到最小（最大）值，存放在排序数列的起始位置，然后再从未排序元素中继续寻找最小（最大）值，然后放到已排序序列的末尾，以此类推，直到所有的元素排序完成。

算法的核心是找到未排序数组中的最小（最大）值，然后进行交换。



插入排序

通过构建有序序列，对于未排序数据，在已排序中从后往前扫描，找到相应位置并插入。

描述：

​	1.从第一个元素开始，该元素可以认为已经被排序；

​	2.取出下一个元素，在已经排序的元素序列中从后往前扫描，

​	3.如果该元素（已排序）大于新元素，将该元素移动到下一位置；

​	4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；

​	5.将新元素插入到该位置；

​	6.重复2~5





希尔排序

将整个待排序的记录序列分割成若干子序列分别进行插入排序

​	1.选择增量序列t1，t2，。。。tk；

​	2.按增量序列k，对序列进行k趟排序；

​	3.每趟排序，根据对应的增量ti；将待排序序列分割成若干长度为m的子序列，分别对各子表进行插入排序。





归并排序

建立在归并操作上的一种有效的排序算法，算法采用分治法，将有序的子序列进行合并，得到完全有序的序列，即先让子序列有序，然后再使子序列间段有序，将两个有序表合并成一个有序表，2-路归并。